#pragma kernel GenerateSymbols
#pragma kernel GenerateVal

struct KeyValue
{
    uint key;
    uint value;
    uint count;
};

RWStructuredBuffer <uint> SymbolBuffer;
RWStructuredBuffer<uint> OriginalBuffer;
RWStructuredBuffer<uint> ToBeCompressedBuffer;

RWStructuredBuffer<KeyValue> HashBuffer;
AppendStructuredBuffer<uint> dict;

extern uint e_seed;
extern uint e_numberOfSymbols;

extern uint e_hashBufferSize;

static uint s_randomLimit = 0xffffffff;
static uint s_empty = 0xffffffff;


uint rand(uint s, uint seed, uint limit)
{
    s += seed;
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s & (limit - 1);
}

uint hash(uint k)
{
    k ^= k >> 16;
    k *= 0x85ebca6b;
    k ^= k >> 13;
    k *= 0xc2b2ae35;
    k ^= k >> 16;
    return k & (e_hashBufferSize - 1);
}

/*
void HashInsert(RWStructuredBuffer<KeyValue> _hashBuffer, uint key, uint value)
{
    uint slot = hash(key);

    while (true)
    {
        uint prev;

        InterlockedCompareExchange(_hashBuffer[slot].key, s_empty, key, prev);

        if (prev == s_empty || prev == key)
        {
            _hashBuffer[slot].value = value;
            return;
        }

        slot = (slot + 1) & (e_hashBufferSize - 1);
    }
}
*/

void HashInsert(RWStructuredBuffer<KeyValue> _hashBuffer, uint key)
{
    uint slot = hash(key);

    while (true)
    {
        uint prev;

        InterlockedCompareExchange(_hashBuffer[slot].key, s_empty, key, prev);

        if (prev == s_empty)
        {
            _hashBuffer[slot].value = value;
            InterlockedAdd(_hashBuffer[slot].count, 1);
            return;
        }
        if(prev == key)
        {
            InterlockedAdd(_hashBuffer[slot].count, 1);
        }

            slot = (slot + 1) & (e_hashBufferSize - 1);
    }
}


uint HashLookup(RWStructuredBuffer<KeyValue> _hashBuffer, uint key)
{
    uint slot = hash(key);

    while (true)
    {
        if (_hashBuffer[slot].key == key)
        {
            return _hashBuffer[slot].value;
        }
        if (_hashBuffer[slot].key == s_empty)
        {
            return s_empty;
        }

        slot = (slot + 1) & (e_hashBufferSize - 1);
    }
}

//Create the list of symbols
[numthreads(1024, 1, 1)]
void GenerateSymbols(uint3 id : SV_DispatchThreadID)
{
    if(id.x < e_numberOfSymbols)
    {
        SymbolBuffer[id.x] = rand(id.x, e_seed, s_randomLimit);
    }
}

[numthreads(1024, 1, 1)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
    if(id.x < e_hashBufferSize)
    {
        HashBuffer[id.x].key = s_empty;
        HashBuffer[id.x].value = s_empty;
        HashBuffer[id.x].count = 0;
    }

}

[numthreads(1024,1,1)]
void GenerateVal (uint3 id : SV_DispatchThreadID)
{
    OriginalBuffer[id.x] = SymbolBuffer[rand(id.x, e_seed, e_numberOfSymbols)];
    ToBeCompressedBuffer[id.x] = OriginalBuffer[id.x];
}

[numthreads(1024, 1, 1)]
void Dictionary(uint3 id : SV_DispatchThreadID)
{
    HashInsert(HashBuffer, ToBeCompressedBuffer[id.x]);
}